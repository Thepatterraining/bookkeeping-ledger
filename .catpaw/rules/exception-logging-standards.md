---
ruleType: Model Request
description: 异常处理和日志记录规范，包含异常捕获、日志输出等规约
globs:
---
rule编写规则: https://km.sankuai.com/collabpage/2710344014

# 异常处理和日志规约

## 异常处理规范

### 异常使用原则
- 【强制】异常不要用来做流程控制，条件控制
- 【强制】捕获异常与抛异常必须完全匹配，或者捕获异常是抛异常的父类
- 【建议】定义时区分unchecked/checked异常，避免直接抛出RuntimeException
- 【建议】方法返回值尽量不返回null，可以返回空集合或空对象，或使用Optional

### NPE防护
- 【强制】防止NPE，是程序员的基本修养，注意以下场景：
  - 方法声明返回基本类型时，必须避免返回结果为null
  - 数据库查询结果可能是null
  - 允许存储null值的非空集合，取数结果可能为null
  - 远程调用返回的对象，需进行NPE检查
  - Session中获取的数据，需进行NPE检查
  - 级联调用obj.getA().getB().getC()，易产生NPE

### 异常处理细则
- 【强制】catch时需区分稳定代码和非稳定代码，对非稳定代码的catch应区分异常类型
- 【强制】可通过预检查方式规避的RuntimeException异常，不应通过catch处理
- 【强制】调用RPC、二方包或动态生成类的相关方法时，使用Throwable捕捉异常
- 【强制】事务场景中，抛出异常被catch后，如果需要回滚，注意手动回滚事务
- 【强制】finally块必须对资源对象、流对象进行关闭，优先考虑try-with-resources
- 【强制】不要在finally块中使用return

## 日志规约

### 日志框架使用
- 【强制】应用中不可直接依赖具体日志系统(Log4j或Logback)的API，而应依赖日志框架(SLF4J或JCL)API
- 【强制】应用中的扩展日志命名包含四要素：appName、logType、logName、logTime

### 日志输出规范
- 【强制】日志输出时，字符串变量之间的拼接使用占位符的方式
  ```java
  logger.debug("Processing trade with id : {} and symbol : {}", id, symbol);
  ```
- 【强制】避免重复打印日志，务必在日志配置文件中设置additivity=false
- 【强制】异常信息应该包括两类信息：案发现场信息和异常信息
- 【强制】对于trace/debug级别的日志输出，必须进行日志级别的开关判断

### 日志输出限制
- 【强制】生产环境禁止使用System.out或System.err输出或使用e.printStackTrace()打印异常堆栈
- 【建议】谨慎地记录日志，生产环境禁止输出debug日志；有选择地输出info日志
- 【建议】统计类的info日志用Cat打点替代
- 【建议】可以使用warn日志级别来记录用户输入参数错误的情况

### 日志内容规范
- 【建议】尽量用英文来描述日志错误信息，如果英文描述不清楚可以使用中文
- 【建议】日志打印时仅打印出业务相关属性值或者调用其对象的toString()方法
- 【建议】日志文件滚动保存15天，建议日志存放logcenter中方便查询
- 【强制】控制单行日志数据内容大小，不得将长度不可控的数组等内容使用JSON序列化后进行日志打印输出

## 单元测试规约

### 基本原则
- 【强制】单测必须遵守AIR原则，具有自动化、独立性、可重复执行的特点
- 【强制】单测要及时更新，以保障测试质量
- 【强制】单测粒度要足够小，至多是类级别，一般是方法级别
- 【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过
- 【强制】单测代码写在工程目录中：src/test/(java,groovy等)，不允许写在业务代码目录下

### 测试要求
- 【建议】单测基本目标：行覆盖率达到70%；核心模块的行覆盖率和分支覆盖率都要达到100%
- 【建议】编写单测代码遵守BCDE原则：Border(边界值测试)、Correct(正确输入)、Design(与设计文档结合)、Error(强制错误信息输入)
- 【建议】对于不可测的代码建议做必要的重构，使代码变得可测
